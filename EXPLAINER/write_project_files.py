#!/usr/bin/env python3
"""
write_project_files.py
Writes SPEC.md, scene.toml, and context_capsule.txt into the current directory.

Usage:
  python write_project_files.py
"""
from pathlib import Path

SPEC = '# SPEC.md — Synthetic Moon Images with Sunlight + Earthlight (Earthshine)\n\n## Goal\nCreate a modular Python renderer that generates synthetic 512×512 monochrome (initially) images of the Moon as seen from a specified observer in space or on Earth. Illumination must include **direct sunlight** and **earthlight** (sunlight reflected by Earth). Geometry must come from **celestial mechanics** (SPICE). No parallel-ray approximations: all illumination directions derived from finite-distance bodies.\n\n## Key Requirements\n- **Image geometry**\n  - Image size: **512 × 512**\n  - Field of view: **1.0° × 1.0°** (square)\n  - Camera model: pinhole/gnomonic projection (upgradeable)\n- **Time handling**\n  - One UTC timestamp per image (exposures are milliseconds)\n  - Store **full Julian Date** in FITS header as **f15.7**: `JD-OBS`\n  - Do **not** use MJD anywhere\n- **Numeric pipeline**\n  - Compute radiance/intensity in **floating point** throughout (float32/float64)\n  - Earthshine is faint: avoid 8-bit rendering\n- **Output**\n  - Store outputs as **16-bit FITS** images\n  - Use **BSCALE/BZERO** to preserve floating-point physical values when storing as int16\n  - Include an **extensive FITS header** with full provenance and settings\n- **Physics / realism**\n  - Moon surface includes **lunar orography** (DEM-based)\n  - Moon reflectance: **Lambert first**, later upgradeable to **Hapke**\n  - Earth reflectance: **map-based albedo** + simple reflectance (Lambert first), later spectral/BRDF upgrades\n  - Earth is an **extended source**: Earthlight computed as a disk integral; visible Earth varies across lunar surface points\n  - Shadowing:\n    - v0: simple (sign tests / optional coarse terrain checks)\n    - later: upgradeable to better terrain self-shadowing (horizon maps / ray casting)\n\n## Geometry (SPICE)\nUse SPICE via SpiceyPy for:\n- Sun/Earth/Moon positions at UTC\n- Body-fixed frames (e.g. IAU_EARTH, IAU_MOON)\n- Observer location:\n  - Earth surface lon/lat/height OR spacecraft state vector\n- Frame transforms for camera pointing and for mapping surface points to lon/lat\n\n## Performance Principles (avoid wasted work)\n- Render only the Moon ROI on the detector (compute apparent Moon disk → bounding box)\n- Cheap ray–Moon bounding sphere/ellipsoid test first; drop misses immediately\n- DEM intersection via iterative “sphere + DEM displacement” (v0), upgradeable to mesh/BVH later\n- Earthlight:\n  - treat Earth as extended disk\n  - avoid per-pixel Earth facet loops by using **tiling / caching**:\n    - compute Earth-disk sample directions & Earth-hit mapping for one representative point per tile\n    - reuse within tile; refine tiles near limb/horizon as needed\n  - early-out when Earth is below local horizon\n\n## Modular Architecture\nAll user choices live in a single central config (TOML). Suggested modules:\n\n- `config.py` — load/validate config, expose one Config object\n- `spice/`\n  - `kernels.py` — meta-kernel handling, kernel provenance logging\n  - `geometry.py` — states, frames, time conversions (UTC↔ET↔JD)\n- `camera.py` — pixel rays, camera pointing/roll, FOV handling\n- `moon/`\n  - `dem.py` — DEM sampling, gradients → normals\n  - `surface.py` — ray hit refine (sphere+DEM); later mesh intersection\n  - `brdf.py` — Lambert now, Hapke later (same interface)\n- `earth/`\n  - `map.py` — albedo sampling\n  - `brdf.py` — Lambert now; later ocean/glint/clouds/spectral\n  - `extended_source.py` — Earth-disk quadrature + per-tile caching\n- `illumination.py` — sunlight + earthlight irradiance at lunar points\n- `render.py` — orchestration, masks, tiling, outputs\n- `io_fits.py` — FITS writer with int16 scaling + extensive header\n\n## Config (single source of truth)\nA `scene.toml` config controls all run-time choices, including:\n- UTC timestamp\n- observer specification\n- camera FOV, image size, roll\n- DEM and albedo map paths\n- illumination toggles and sampling counts\n- shadowing mode\n- output paths and metadata tags\n\n## FITS Header Requirements\nMust include at least:\n- `JD-OBS` as **string** formatted `f15.7`\n- UTC string: `DATE-OBS` (ISO8601)\n- Observer definition (site or spacecraft)\n- Camera: `NAXIS1/2`, `FOV_DEG`, `CRPIX*`, `CDELT*`, pointing definition\n- Key geometry scalars: observer–Moon range, Moon phase angle, Earth angular diameter (as seen from Moon centre or representative point), etc.\n- Data provenance: DEM/albedo filenames, kernel list / meta-kernel name\n- Physics settings: BRDF modes, sample counts, tile size, shadow mode\n- Scaling: BSCALE/BZERO and physical units (`BUNIT`)\n\n## Planned Upgrades\n1) Spectral/filtered rendering:\n- wavelength grid + solar spectrum\n- wavelength-dependent BRDFs (Earth + Moon)\n\n2) Moon Hapke photometry:\n- global params initially; later spatially varying parameter maps\n\n3) Better shadowing:\n- horizon maps or ray casting against a mesh\n\n4) Sensor realism:\n- PSF, exposure, noise model (optional)\n'
SCENE = '[time]\nutc = "2026-02-13T03:12:45Z"\n\n[observer]\nmode = "earth_site"  # "earth_site" | "spacecraft_state"\nlon_deg = 12.5683\nlat_deg = 55.6761\nheight_m = 20.0\n# If spacecraft_state:\n# frame = "J2000"\n# x_km = 0.0\n# y_km = 0.0\n# z_km = 0.0\n# vx_km_s = 0.0\n# vy_km_s = 0.0\n# vz_km_s = 0.0\n\n[camera]\nnx = 512\nny = 512\nfov_deg = 1.0\nroll_deg = 0.0\npointing = "moon_center"  # later: explicit RA/Dec, etc.\n\n[paths]\nspice_kernels_dir = "KERNELS"\nmoon_dem = "DATA/moon_lola_dem.tif"\nmoon_albedo = "DATA/moon_albedo.tif"\nearth_albedo = "DATA/earth_albedo.tif"\nout_fits = "OUTPUT/synth_moon.fits"\n\n[moon]\nshape = "sphere_plus_dem"  # later: "mesh"\nbrdf = "lambert"           # later: "hapke"\n\n[earth]\nbrdf = "lambert"\nearth_disk_samples = 192\nearthlight_tile_px = 16\n\n[illumination]\ninclude_sun = true\ninclude_earthlight = true\n\n[shadows]\nmode = "simple"            # later: "horizon" | "raycast_mesh"\n\n[output]\nstore_int16 = true\nbunit = "I/F"              # or "W m-2 sr-1" later\nstore_float_extension = true\n'
CAPSULE = 'We’re building a modular Python renderer for synthetic Moon images (512×512, 1°×1° FOV) with correct SPICE celestial geometry. Illumination includes sunlight + extended-source earthlight (earthshine). Moon surface uses a DEM for orography; Lambert initially, Hapke later; spectral rendering later (solar spectrum + wavelength-dependent BRDFs). Compute everything in float; output 16-bit FITS using BSCALE/BZERO; extensive FITS header including JD-OBS formatted as f15.7 (no MJD). User choices live in one scene.toml config. Performance: render Moon ROI only; cheap bounding-sphere hit mask; DEM refine; earthlight via Earth-disk quadrature with tile caching and horizon early-outs.\n'

def main() -> None:
    Path("SPEC.md").write_text(SPEC, encoding="utf-8")
    Path("scene.toml").write_text(SCENE, encoding="utf-8")
    Path("context_capsule.txt").write_text(CAPSULE, encoding="utf-8")
    print("Wrote: SPEC.md scene.toml context_capsule.txt")

if __name__ == "__main__":
    main()
